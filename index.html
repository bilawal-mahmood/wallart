<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Virtual Wall AR</title>
  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <style>
    html, body { margin: 0; padding: 0; overflow: hidden; }
    #renderCanvas { width: 100%; height: 100%; touch-action: none; }
    #log {
      position: absolute;
      bottom: 10px;
      left: 10px;
      background: rgba(0,0,0,0.6);
      color: lime;
      font-size: 14px;
      padding: 10px;
      max-width: 90%;
      z-index: 10;
      font-family: monospace;
      border-radius: 5px;
    }
  </style>
</head>
<body>
  <canvas id="renderCanvas"></canvas>
  <div id="log">Initializingâ€¦</div>

  <script>
    let engine, scene, logBox, reticle, placedImage;
    let lastTilt = 0;

    const log = msg => {
      console.log(msg);
      document.getElementById("log").innerText = "Status: " + msg;
    };

    async function createScene() {
      const canvas = document.getElementById("renderCanvas");
      engine = new BABYLON.Engine(canvas, true);
      scene = new BABYLON.Scene(engine);
      logBox = document.getElementById("log");

      new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);

      const xr = await BABYLON.WebXRDefaultExperience.CreateAsync(scene, {
        uiOptions: {
          sessionMode: "immersive-ar",
          referenceSpaceType: "local"
        },
        optionalFeatures: true
      });

      log("WebXR started");

      const hitTest = await xr.baseExperience.featuresManager.enableFeature(
        BABYLON.WebXRHitTest.Name, "latest", { xrInput: xr.input }
      );

      // Strip reticle
      reticle = BABYLON.MeshBuilder.CreateBox("strip", {
        width: 0.4, height: 0.01, depth: 0.05
      }, scene);
      reticle.material = new BABYLON.StandardMaterial("mat", scene);
      reticle.material.diffuseColor = new BABYLON.Color3(0, 1, 0);
      reticle.isVisible = false;

      hitTest.onHitTestResultObservable.add(results => {
        if (results.length) {
          const hit = results[0];
          hit.transformationMatrix.decompose(undefined, undefined, reticle.position);
          reticle.isVisible = true;
          log("Ready: Tap to place image");
        }
      });

      // Place image on tap
      scene.onPointerDown = () => {
        if (!reticle.isVisible || placedImage) return;

        const plane = BABYLON.MeshBuilder.CreatePlane("art", {
          width: 0.6, height: 0.6
        }, scene);
        plane.position = reticle.position.clone();
        plane.position.y += 0.3;
        plane.rotationQuaternion = BABYLON.Quaternion.RotationAxis(BABYLON.Axis.Y, xr.baseExperience.camera.rotation.y);

        const mat = new BABYLON.StandardMaterial("imgMat", scene);
        mat.diffuseTexture = new BABYLON.Texture("art.png", scene);
        mat.emissiveColor = new BABYLON.Color3(1, 1, 1);
        plane.material = mat;

        placedImage = plane;
        lastTilt = getCameraPitch(xr.baseExperience.camera);
        log("Image placed. Tilt phone up/down to move image.");
      };

      // Run loop: detect phone tilt
      scene.onBeforeRenderObservable.add(() => {
        if (placedImage) {
          const pitch = getCameraPitch(xr.baseExperience.camera);
          const diff = pitch - lastTilt;

          if (Math.abs(diff) > 0.01) {
            placedImage.position.y += diff * 2; // sensitivity
            lastTilt = pitch;
          }
        }
      });

      engine.runRenderLoop(() => scene.render());
      window.addEventListener("resize", () => engine.resize());
    }

    // Helper: get pitch from camera quaternion (rotation around X)
    function getCameraPitch(camera) {
      const forward = camera.getDirection(BABYLON.Axis.Z);
      return Math.asin(forward.y); // y = up/down component of forward vector
    }

    createScene().catch(err => {
      console.error(err);
      log("Error: " + err.message);
    });
  </script>
</body>
</html>
