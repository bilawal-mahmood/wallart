<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Wall AR - Controlled Image Movement</title>
  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <style>
    html, body { margin: 0; padding: 0; overflow: hidden; }
    #renderCanvas { width: 100%; height: 100%; touch-action: none; }
    #log {
      position: absolute;
      bottom: 10px;
      left: 10px;
      background: rgba(0,0,0,0.6);
      color: lime;
      font-size: 14px;
      padding: 10px;
      max-width: 90%;
      z-index: 10;
      font-family: monospace;
      border-radius: 5px;
    }
  </style>
</head>
<body>
  <canvas id="renderCanvas"></canvas>
  <div id="log">Initializing…</div>

  <script>
    let engine, scene, camera, reticle, placedImage;
    let reticlePlaced = false;
    let baseStripY = 0;
    let currentHeight = 0.3;
    let movementEnabled = false;
    let lastPitch = 0;

    const log = msg => document.getElementById("log").innerText = "Status: " + msg;

    async function createScene() {
      const canvas = document.getElementById("renderCanvas");
      engine = new BABYLON.Engine(canvas, true);
      scene = new BABYLON.Scene(engine);
      new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);

      const xr = await BABYLON.WebXRDefaultExperience.CreateAsync(scene, {
        uiOptions: { sessionMode: "immersive-ar" },
        optionalFeatures: true
      });

      camera = xr.baseExperience.camera;

      // Ground plane (invisible)
      const ground = BABYLON.MeshBuilder.CreateGround("ground", { width: 100, height: 100 }, scene);
      ground.isVisible = false;

      // Strip (reticle) at floor level
      reticle = BABYLON.MeshBuilder.CreateBox("reticle", {
        width: 0.6, height: 0.01, depth: 0.02
      }, scene);
      const mat = new BABYLON.StandardMaterial("retMat", scene);
      mat.diffuseColor = new BABYLON.Color3(0, 1, 0);
      reticle.material = mat;
      reticle.isVisible = true;
      reticle.position = new BABYLON.Vector3(0, -999, 0); // hide initially

      // Per-frame logic
      scene.onBeforeRenderObservable.add(() => {
        if (!reticlePlaced) {
          // Strip follows floor hit point
          const ray = camera.getForwardRay(10);
          const hit = scene.pickWithRay(ray, m => m.name === "ground");

          if (hit && hit.pickedPoint) {
            const target = hit.pickedPoint.clone();
            target.y += 0.005;

            reticle.position = BABYLON.Vector3.Lerp(reticle.position, target, 0.4);
            const camY = camera.rotationQuaternion.toEulerAngles().y;
            reticle.rotationQuaternion = BABYLON.Quaternion.RotationAxis(BABYLON.Axis.Y, camY);

            log("Aim strip at wall base. Tap to place image.");
          }
        }

        if (reticlePlaced && placedImage && movementEnabled) {
          // Move image based on pitch
          const forward = camera.getDirection(BABYLON.Axis.Z);
          const pitch = Math.asin(forward.y); // -π/2 to +π/2
          lastPitch = pitch; // store only when moving

          const speed = 0.10; // increased speed multiplier
          currentHeight += -pitch * speed;

          // Clamp movement
          currentHeight = Math.max(0.1, Math.min(2.0, currentHeight));
          placedImage.position.y = baseStripY + currentHeight;

          log("Tilt to move image. Tap again to stop.");
        }

        if (reticlePlaced && placedImage && !movementEnabled) {
          // Lock image at current height
          placedImage.position.y = baseStripY + currentHeight;
        }
      });

      // Tap: Place or toggle
      scene.onPointerDown = () => {
        if (!reticlePlaced) {
          baseStripY = reticle.position.y;
          currentHeight = 0.3;

          const image = BABYLON.MeshBuilder.CreatePlane("art", {
            width: 0.6, height: 0.6
          }, scene);
          image.position = reticle.position.clone();
          image.position.y = baseStripY + currentHeight;

          const camY = camera.rotationQuaternion.toEulerAngles().y;
          image.rotationQuaternion = BABYLON.Quaternion.RotationAxis(BABYLON.Axis.Y, camY);

          const imgMat = new BABYLON.StandardMaterial("imgMat", scene);
          imgMat.diffuseTexture = new BABYLON.Texture("art.png", scene);
          imgMat.emissiveColor = new BABYLON.Color3(1, 1, 1);
          image.material = imgMat;

          placedImage = image;
          reticlePlaced = true;
          movementEnabled = true;

          log("Image placed. Tilt phone to move image.");
        } else if (placedImage) {
          movementEnabled = !movementEnabled;
          log(movementEnabled ? "Movement enabled. Tilt to move." : "Image locked.");
        }
      };

      engine.runRenderLoop(() => scene.render());
      window.addEventListener("resize", () => engine.resize());
    }

    createScene().catch(err => {
      console.error(err);
      log("Error: " + err.message);
    });
  </script>
</body>
</html>
