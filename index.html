<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Babylon WebXR Wall Placement</title>
  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <style>
    html, body { margin: 0; padding: 0; overflow: hidden; }
    #renderCanvas { width: 100%; height: 100%; touch-action: none; }
    #log {
      position: absolute;
      bottom: 10px;
      left: 10px;
      background: rgba(0,0,0,0.6);
      color: lime;
      font-size: 14px;
      padding: 10px;
      max-width: 90%;
      z-index: 10;
      font-family: monospace;
      border-radius: 5px;
    }
  </style>
</head>
<body>
  <canvas id="renderCanvas"></canvas>
  <div id="log">Initializingâ€¦</div>

  <script>
    let engine, scene, camera, reticle, placedImage;
    let reticlePlaced = false;
    const log = msg => document.getElementById("log").innerText = "Status: " + msg;

    async function createScene() {
      const canvas = document.getElementById("renderCanvas");
      engine = new BABYLON.Engine(canvas, true);
      scene = new BABYLON.Scene(engine);
      new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);

      const xr = await BABYLON.WebXRDefaultExperience.CreateAsync(scene, {
        uiOptions: { sessionMode: "immersive-ar" },
        optionalFeatures: true
      });

      camera = xr.baseExperience.camera;

      // Invisible ground mesh
      const ground = BABYLON.MeshBuilder.CreateGround("ground", { width: 100, height: 100 }, scene);
      ground.isVisible = false;

      // Reticle strip on floor
      reticle = BABYLON.MeshBuilder.CreateBox("reticle", {
        width: 0.6, height: 0.01, depth: 0.02
      }, scene);
      const mat = new BABYLON.StandardMaterial("retMat", scene);
      mat.diffuseColor = new BABYLON.Color3(0, 1, 0);
      reticle.material = mat;
      reticle.isVisible = true;
      reticle.position = new BABYLON.Vector3(0, -999, 0); // start hidden

      // Simulate center-screen raycast every frame
      scene.onBeforeRenderObservable.add(() => {
        if (reticlePlaced) return;

        const ray = camera.getForwardRay(10);
        const hit = scene.pickWithRay(ray, mesh => mesh.name === "ground");

        if (hit && hit.pickedPoint) {
          const target = hit.pickedPoint.clone();
          target.y += 0.005;

          reticle.position = BABYLON.Vector3.Lerp(reticle.position, target, 0.4);

          // Rotate strip to match camera Y
          const camY = camera.rotationQuaternion.toEulerAngles().y;
          reticle.rotationQuaternion = BABYLON.Quaternion.RotationAxis(BABYLON.Axis.Y, camY);

          log("Aim at bottom of wall and tap");
        }
      });

      // Tap to place image upright on wall
      scene.onPointerDown = () => {
        if (reticlePlaced || !reticle) return;

        const image = BABYLON.MeshBuilder.CreatePlane("art", {
          width: 0.6, height: 0.6
        }, scene);
        image.position = reticle.position.clone();
        image.position.y += 0.3;

        const camY = camera.rotationQuaternion.toEulerAngles().y;
        image.rotationQuaternion = BABYLON.Quaternion.RotationAxis(BABYLON.Axis.Y, camY);

        const imgMat = new BABYLON.StandardMaterial("imgMat", scene);
        imgMat.diffuseTexture = new BABYLON.Texture("art.png", scene);
        imgMat.emissiveColor = new BABYLON.Color3(1, 1, 1);
        image.material = imgMat;

        placedImage = image;
        reticlePlaced = true;
        log("Image placed.");
      };

      engine.runRenderLoop(() => scene.render());
      window.addEventListener("resize", () => engine.resize());
    }

    createScene().catch(err => {
      console.error(err);
      log("Error: " + err.message);
    });
  </script>
</body>
</html>
