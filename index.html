<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Virtual Wall AR</title>
  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <style>
    html, body { margin: 0; padding: 0; overflow: hidden; background: black; }
    #renderCanvas { width: 100%; height: 100%; touch-action: none; }
    #log {
      position: absolute;
      bottom: 10px;
      left: 10px;
      background: rgba(0,0,0,0.6);
      color: lime;
      font-size: 14px;
      padding: 10px;
      max-width: 90%;
      z-index: 10;
      font-family: monospace;
      border-radius: 5px;
    }
  </style>
</head>
<body>
  <canvas id="renderCanvas"></canvas>
  <div id="log">Initializingâ€¦</div>

  <script>
    let engine, scene, logBox, reticle, placedImage, isDragging = false;
    let dragStartX = 0, dragStartY = 0;

    const log = msg => {
      console.log(msg);
      document.getElementById("log").innerText = "Status: " + msg;
    };

    async function createScene() {
      const canvas = document.getElementById("renderCanvas");
      engine = new BABYLON.Engine(canvas, true);
      scene = new BABYLON.Scene(engine);
      logBox = document.getElementById("log");

      new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);

      const xr = await BABYLON.WebXRDefaultExperience.CreateAsync(scene, {
        uiOptions: { sessionMode: "immersive-ar" },
        optionalFeatures: true
      });

      log("WebXR started");

      const hitTest = await xr.baseExperience.featuresManager.enableFeature(
        BABYLON.WebXRHitTest.Name, "latest", { xrInput: xr.input }
      );

      // STRIP instead of circle
      reticle = BABYLON.MeshBuilder.CreateBox("strip", {
        width: 0.4, height: 0.01, depth: 0.05
      }, scene);
      reticle.material = new BABYLON.StandardMaterial("mat", scene);
      reticle.material.diffuseColor = new BABYLON.Color3(0, 1, 0);
      reticle.isVisible = false;

      hitTest.onHitTestResultObservable.add(results => {
        if (results.length) {
          const hit = results[0];
          hit.transformationMatrix.decompose(undefined, undefined, reticle.position);
          reticle.isVisible = true;
          log("Ready: Tap to place image");
        }
      });

      scene.onPointerDown = (evt, pickResult) => {
        if (!reticle.isVisible || placedImage) return;

        // Create upright plane (image) facing user
        const plane = BABYLON.MeshBuilder.CreatePlane("art", {
          width: 0.6, height: 0.6
        }, scene);
        plane.position = reticle.position.clone();
        plane.position.y += 0.3; // lift above strip
        plane.rotationQuaternion = BABYLON.Quaternion.RotationAxis(BABYLON.Axis.Y, xr.baseExperience.camera.rotation.y);

        const mat = new BABYLON.StandardMaterial("imgMat", scene);
        mat.diffuseTexture = new BABYLON.Texture("art.png", scene);
        mat.emissiveColor = new BABYLON.Color3(1, 1, 1);
        plane.material = mat;

        placedImage = plane;
        log("Image placed. Swipe to move.");
      };

      // Drag logic for screen swipe
      scene.onPointerObservable.add((pointerInfo) => {
        if (!placedImage) return;

        switch (pointerInfo.type) {
          case BABYLON.PointerEventTypes.POINTERDOWN:
            isDragging = true;
            dragStartX = pointerInfo.event.clientX;
            dragStartY = pointerInfo.event.clientY;
            break;
          case BABYLON.PointerEventTypes.POINTERUP:
            isDragging = false;
            break;
          case BABYLON.PointerEventTypes.POINTERMOVE:
            if (isDragging) {
              const dx = (pointerInfo.event.clientX - dragStartX) * 0.0015;
              const dy = (pointerInfo.event.clientY - dragStartY) * 0.0015;
              placedImage.position.x += dx;
              placedImage.position.y -= dy;
              dragStartX = pointerInfo.event.clientX;
              dragStartY = pointerInfo.event.clientY;
              log("Moving image");
            }
            break;
        }
      });

      engine.runRenderLoop(() => scene.render());
      window.addEventListener("resize", () => engine.resize());
    }

    createScene().catch(err => {
      console.error(err);
      log("Error: " + err.message);
    });
  </script>
</body>
</html>
