<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Wall AR Tilt-Controlled Placement</title>
  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <style>
    html, body { margin: 0; padding: 0; overflow: hidden; }
    #renderCanvas { width: 100%; height: 100%; touch-action: none; }
    #log {
      position: absolute;
      bottom: 10px;
      left: 10px;
      background: rgba(0,0,0,0.6);
      color: lime;
      font-size: 14px;
      padding: 10px;
      max-width: 90%;
      z-index: 10;
      font-family: monospace;
      border-radius: 5px;
    }
  </style>
</head>
<body>
  <canvas id="renderCanvas"></canvas>
  <div id="log">Initializingâ€¦</div>

  <script>
    let engine, scene, reticle, placedImage;
    let reticlePlaced = false;
    let dragPlaneY = 0;
    const moveSpeed = 0.03;
    const maxDistance = 2.0;

    const log = msg => document.getElementById("log").innerText = "Status: " + msg;

    async function createScene() {
      const canvas = document.getElementById("renderCanvas");
      engine = new BABYLON.Engine(canvas, true);
      scene = new BABYLON.Scene(engine);
      new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);

      const xr = await BABYLON.WebXRDefaultExperience.CreateAsync(scene, {
        uiOptions: { sessionMode: "immersive-ar" },
        optionalFeatures: true
      });

      const hitTest = await xr.baseExperience.featuresManager.enableFeature(
        BABYLON.WebXRHitTest.Name, "latest", { xrInput: xr.input }
      );

      // Reticle strip
      reticle = BABYLON.MeshBuilder.CreateBox("strip", {
        width: 0.6, height: 0.01, depth: 0.02
      }, scene);
      const mat = new BABYLON.StandardMaterial("retMat", scene);
      mat.diffuseColor = new BABYLON.Color3(0, 1, 0);
      reticle.material = mat;
      reticle.isVisible = false;

      let initialSet = false;

      hitTest.onHitTestResultObservable.add(results => {
        if (results.length && !initialSet) {
          let hit = results[0];
          let scale = new BABYLON.Vector3();
          let rotation = new BABYLON.Quaternion();
          let position = new BABYLON.Vector3();
          hit.transformationMatrix.decompose(scale, rotation, position);

          const camY = xr.baseExperience.camera.rotationQuaternion.toEulerAngles().y;
          reticle.rotationQuaternion = BABYLON.Quaternion.RotationAxis(BABYLON.Axis.Y, camY);
          reticle.position = position.clone();
          reticle.position.y += 0.005;
          dragPlaneY = reticle.position.y;

          reticle.isVisible = true;
          initialSet = true;
          log("Tilt phone to move strip. Tap to place image.");
        }
      });

      // Tilt-based reticle movement
      scene.onBeforeRenderObservable.add(() => {
        if (!reticle.isVisible || reticlePlaced) return;

        const camera = xr.baseExperience.camera;
        const forward = camera.getDirection(BABYLON.Axis.Z);
        const right = camera.getDirection(BABYLON.Axis.X);

        const pitch = Math.asin(forward.y); // forward/back
        const roll = Math.asin(right.y);    // left/right

        let movement = new BABYLON.Vector3();

        // Horizontal tilt (roll): move left/right
        movement.addInPlace(new BABYLON.Vector3(right.x, 0, right.z).scale(-roll * moveSpeed));

        // Vertical tilt (pitch): move forward/back
        movement.addInPlace(new BABYLON.Vector3(forward.x, 0, forward.z).scale(-pitch * moveSpeed));

        reticle.position.addInPlace(movement);
        reticle.position.y = dragPlaneY;

        // Clamp max distance from camera to 2m
        const distance = BABYLON.Vector3.Distance(reticle.position, camera.position);
        if (distance > maxDistance) {
          const dir = reticle.position.subtract(camera.position).normalize();
          reticle.position = camera.position.add(dir.scale(maxDistance));
          reticle.position.y = dragPlaneY;
        }
      });

      // Tap to place image and freeze reticle
      scene.onPointerDown = () => {
        if (!reticle.isVisible || placedImage) return;

        const plane = BABYLON.MeshBuilder.CreatePlane("art", {
          width: 0.6, height: 0.6
        }, scene);
        plane.position = reticle.position.clone();
        plane.position.y += 0.3;

        const camY = xr.baseExperience.camera.rotationQuaternion.toEulerAngles().y;
        plane.rotationQuaternion = BABYLON.Quaternion.RotationAxis(BABYLON.Axis.Y, camY);

        const mat = new BABYLON.StandardMaterial("imgMat", scene);
        mat.diffuseTexture = new BABYLON.Texture("art.png", scene);
        mat.emissiveColor = new BABYLON.Color3(1, 1, 1);
        plane.material = mat;

        placedImage = plane;
        reticlePlaced = true;
        log("Image placed. Reticle is now frozen.");
      };

      engine.runRenderLoop(() => scene.render());
      window.addEventListener("resize", () => engine.resize());
    }

    createScene().catch(err => {
      console.error(err);
      log("Error: " + err.message);
    });
  </script>
</body>
</html>
